[{"short_id":"fah5nj","short_id_url":"https://lobste.rs/s/fah5nj","created_at":"2024-01-10T01:57:24.000-06:00","title":"How I pwned half of America’s fast food chains, simultaneously","url":"https://mrbruh.com/chattr/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/fah5nj/how_i_pwned_half_america_s_fast_food_chains","submitter_user":{"username":"knl","created_at":"2017-07-21T07:12:24.000-05:00","is_admin":false,"about":"Senior software engineer specialized in distributed systems and low latency, high frequency trading infrastructure.","is_moderator":false,"karma":8607,"avatar_url":"/avatars/knl-100.png","invited_by_user":"james","github_username":"knl","keybase_signatures":[{"kb_username":"knl","sig_hash":"cb1fe17fead6d360f9abca902132b2407ee736f1a243f615ad9757dfe8d17e3b0f"}]},"user_is_author":false,"tags":["security"]},{"short_id":"mew3zf","short_id_url":"https://lobste.rs/s/mew3zf","created_at":"2024-01-10T01:00:52.000-06:00","title":"Vcc - the Vulkan Clang Compiler","url":"https://shady-gang.github.io/vcc/","score":1,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/mew3zf/vcc_vulkan_clang_compiler","submitter_user":{"username":"asb","created_at":"2014-04-01T04:39:53.000-05:00","is_admin":false,"about":"Compiler engineer at Igalia (https://igalia.com). Previously co-founded lowRISC CIC (https://www.lowrisc.org) and served as its CTO for many years.\r\n\r\nWrites LLVM Weekly (https://llvmweekly.org).","is_moderator":false,"karma":609,"avatar_url":"/avatars/asb-100.png","invited_by_user":"kev009","github_username":"asb"},"user_is_author":false,"tags":["compilers","graphics"]},{"short_id":"358mgg","short_id_url":"https://lobste.rs/s/358mgg","created_at":"2024-01-09T18:33:14.000-06:00","title":"Why all([]) is true, prod([]) is 1, etc","url":"https://buttondown.email/hillelwayne/archive/why-any-is-true-prod-is-1-etc/","score":11,"flags":0,"comment_count":12,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/358mgg/why_all_is_true_prod_is_1_etc","submitter_user":{"username":"eBPF","created_at":"2023-01-25T09:58:16.000-06:00","is_admin":false,"about":"","is_moderator":false,"karma":2036,"avatar_url":"/avatars/eBPF-100.png","invited_by_user":"oats"},"user_is_author":false,"tags":["python"]},{"short_id":"0bpj0o","short_id_url":"https://lobste.rs/s/0bpj0o","created_at":"2024-01-09T17:49:03.000-06:00","title":"Error handling in Go web apps shouldn't be so awkward","url":"https://boldlygo.tech/posts/2024-01-08-error-handling/","score":10,"flags":0,"comment_count":14,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/0bpj0o/error_handling_go_web_apps_shouldn_t_be_so","submitter_user":{"username":"jhall","created_at":"2020-11-18T03:01:31.000-06:00","is_admin":false,"about":"The Tiny DevOps Guy ⋄ I help small teams do amazing DevOps.","is_moderator":false,"karma":202,"avatar_url":"/avatars/jhall-100.png","invited_by_user":"iivvoo","github_username":"flimzy","twitter_username":"TinyDevOps"},"user_is_author":true,"tags":["go"]},{"short_id":"wpfxgj","short_id_url":"https://lobste.rs/s/wpfxgj","created_at":"2024-01-09T15:09:06.000-06:00","title":"A Global Design System","url":"https://bradfrost.com/blog/post/a-global-design-system/","score":6,"flags":0,"comment_count":3,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/wpfxgj/global_design_system","submitter_user":{"username":"pronoiac","created_at":"2018-09-24T01:31:00.000-05:00","is_admin":false,"about":"I'm a computer geek working as an SRE in San Francisco. My email is pronoiac@gmail.com.","is_moderator":false,"karma":657,"avatar_url":"/avatars/pronoiac-100.png","invited_by_user":"causal_agent"},"user_is_author":false,"tags":["design","web"]},{"short_id":"67oqth","short_id_url":"https://lobste.rs/s/67oqth","created_at":"2024-01-09T14:46:43.000-06:00","title":"Writing a minimal in-memory storage engine for MySQL/MariaDB","url":"https://notes.eatonphil.com/2024-01-09-minimal-in-memory-storage-engine-for-mysql.html","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/67oqth/writing_minimal_memory_storage_engine","submitter_user":{"username":"eatonphil","created_at":"2019-09-01T20:23:02.000-05:00","is_admin":false,"about":"Info at eatonphil.com.\r\n\r\nphil@eatonphil.com","is_moderator":false,"karma":5629,"avatar_url":"/avatars/eatonphil-100.png","invited_by_user":"calvin","github_username":"eatonphil","twitter_username":"eatonphil"},"user_is_author":true,"tags":["c++","databases"]},{"short_id":"fi5kxp","short_id_url":"https://lobste.rs/s/fi5kxp","created_at":"2024-01-09T12:33:50.000-06:00","title":"Using Git offline","url":"https://www.gibbard.me/using_git_offline/","score":12,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/fi5kxp/using_git_offline","submitter_user":{"username":"telemachus","created_at":"2012-08-10T12:36:05.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":2553,"avatar_url":"/avatars/telemachus-100.png","invited_by_user":"jcs"},"user_is_author":false,"tags":["vcs"]},{"short_id":"famjqw","short_id_url":"https://lobste.rs/s/famjqw","created_at":"2024-01-09T12:14:38.000-06:00","title":"The Two Reacts","url":"https://overreacted.io/the-two-reacts/","score":7,"flags":0,"comment_count":6,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/famjqw/two_reacts","submitter_user":{"username":"adamshaylor","created_at":"2020-10-26T20:04:57.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":2918,"avatar_url":"/avatars/adamshaylor-100.png","invited_by_user":"peterc","github_username":"adamshaylor","keybase_signatures":[{"kb_username":"adamshaylor","sig_hash":"0ebd1a3d88d97f20922147a75889dfcae02b632d94156b9315a6d93384ae2e4f0f"}]},"user_is_author":false,"tags":["javascript","web"]},{"short_id":"l21uzt","short_id_url":"https://lobste.rs/s/l21uzt","created_at":"2024-01-09T11:37:21.000-06:00","title":"Extending the month to infinity","url":"https://feaneron.com/2023/09/15/extending-the-month-to-infinity/","score":8,"flags":0,"comment_count":5,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/l21uzt/extending_month_infinity","submitter_user":{"username":"kevincox","created_at":"2021-04-17T10:12:51.000-05:00","is_admin":false,"about":"Curious Individual\r\n\r\nhttps://kevincox.ca","is_moderator":false,"karma":973,"avatar_url":"/avatars/kevincox-100.png","invited_by_user":"bcongdon"},"user_is_author":false,"tags":["programming"]},{"short_id":"lzvqxc","short_id_url":"https://lobste.rs/s/lzvqxc","created_at":"2024-01-09T10:30:33.000-06:00","title":"Hackers can infect network-connected wrenches to install ransomware","url":"https://arstechnica.com/security/2024/01/network-connected-wrenches-used-in-factories-can-be-hacked-for-sabotage-or-ransomware/","score":3,"flags":0,"comment_count":5,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/lzvqxc/hackers_can_infect_network_connected","submitter_user":{"username":"ollien","created_at":"2023-06-09T11:11:36.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":224,"avatar_url":"/avatars/ollien-100.png","invited_by_user":"miah"},"user_is_author":false,"tags":["security"]},{"short_id":"knhoxl","short_id_url":"https://lobste.rs/s/knhoxl","created_at":"2024-01-09T09:54:39.000-06:00","title":"Comparing lambdas in various languages (2020)","url":"https://brevzin.github.io/c++/2020/06/18/lambda-lambda-lambda/","score":5,"flags":0,"comment_count":6,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/knhoxl/comparing_lambdas_various_languages","submitter_user":{"username":"asb","created_at":"2014-04-01T04:39:53.000-05:00","is_admin":false,"about":"Compiler engineer at Igalia (https://igalia.com). Previously co-founded lowRISC CIC (https://www.lowrisc.org) and served as its CTO for many years.\r\n\r\nWrites LLVM Weekly (https://llvmweekly.org).","is_moderator":false,"karma":609,"avatar_url":"/avatars/asb-100.png","invited_by_user":"kev009","github_username":"asb"},"user_is_author":false,"tags":["plt"]},{"short_id":"dpgjpn","short_id_url":"https://lobste.rs/s/dpgjpn","created_at":"2024-01-09T09:44:38.000-06:00","title":"NumPy 2 is coming: preventing breakage, updating your code","url":"https://pythonspeed.com/articles/numpy-2/","score":8,"flags":0,"comment_count":14,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/dpgjpn/numpy_2_is_coming_preventing_breakage","submitter_user":{"username":"itamarst","created_at":"2016-04-28T10:05:47.000-05:00","is_admin":false,"about":"Writing about Python performance and faster development at https://pythonspeed.com, as well as offering consulting services. Writing about work/life balance and other software engineering skills at https://codewithoutrules.com.\r\n","is_moderator":false,"karma":5914,"avatar_url":"/avatars/itamarst-100.png","invited_by_user":"0x2ba22e11"},"user_is_author":false,"tags":["python"]},{"short_id":"bsfib8","short_id_url":"https://lobste.rs/s/bsfib8","created_at":"2024-01-09T08:53:40.000-06:00","title":"SQLite 3.45: Interactive release notes","url":"https://antonz.org/sqlite-3-45/","score":8,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/bsfib8/sqlite_3_45_interactive_release_notes","submitter_user":{"username":"napkindrawing","created_at":"2014-05-14T10:03:04.000-05:00","is_admin":false,"about":"Dad. Tinkerer. Software developer. he/they.","is_moderator":false,"karma":4603,"avatar_url":"/avatars/napkindrawing-100.png","invited_by_user":"howdoipython"},"user_is_author":false,"tags":["databases","release"]},{"short_id":"1l71am","short_id_url":"https://lobste.rs/s/1l71am","created_at":"2024-01-09T08:19:17.000-06:00","title":"Expr - 5 Years in the Making","url":"https://expr-lang.org/blog/five-years-in-making","score":6,"flags":6,"comment_count":8,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/1l71am/expr_5_years_making","submitter_user":{"username":"antonmedv","created_at":"2018-09-20T00:46:59.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":805,"avatar_url":"/avatars/antonmedv-100.png","invited_by_user":"notriddle"},"user_is_author":true,"tags":["go"]},{"short_id":"omzecu","short_id_url":"https://lobste.rs/s/omzecu","created_at":"2024-01-09T07:09:01.000-06:00","title":"AI Toolkit: Give a brain to your game's NPCs, a header-only C++ library","url":"https://github.com/linkdd/aitoolkit","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/omzecu/ai_toolkit_give_brain_your_game_s_npcs","submitter_user":{"username":"linkdd","created_at":"2023-06-22T15:00:49.000-05:00","is_admin":false,"about":"\u003e Je suis tombé dans l'informatique étant petit, et les effets sont devenus permanent.\r\n\r\nI'm a developer who believes that any line of code merged in master/main is \"legacy\".\r\n\r\nYet, I still write some technical-debt as a hobby:\r\n\r\n  - https://letlang.dev\r\n  - https://kubirds.com\r\n  - https://linkdd.github.io\r\n  - https://david-delassus.medium.com","is_moderator":false,"karma":228,"avatar_url":"/avatars/linkdd-100.png","invited_by_user":"jcs","github_username":"linkdd"},"user_is_author":true,"tags":["ai","programming","show"]},{"short_id":"83z5rh","short_id_url":"https://lobste.rs/s/83z5rh","created_at":"2024-01-09T06:31:10.000-06:00","title":"Embedding the Sophia runtime into Go applications","url":"https://xnacly.me/posts/2024/embed-sophia/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/83z5rh/embedding_sophia_runtime_into_go","submitter_user":{"username":"xnacly","created_at":"2023-05-24T06:49:47.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":74,"avatar_url":"/avatars/xnacly-100.png","invited_by_user":"lpil","github_username":"xNaCly"},"user_is_author":true,"tags":["go","lisp"]},{"short_id":"wlwjvy","short_id_url":"https://lobste.rs/s/wlwjvy","created_at":"2024-01-09T03:57:31.000-06:00","title":"Tail-Recursive \u0026 Body-Recursive Function Performance Across Elixir \u0026 BEAM versions – what’s the impact of the JIT?","url":"https://pragtob.wordpress.com/2024/01/08/tail-recursive-body-recursive-function-performance-across-elixir-beam-versions-whats-the-impact-of-the-jit/","score":9,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/wlwjvy/tail_recursive_body_recursive_function","submitter_user":{"username":"PragTob","created_at":"2014-10-25T16:27:06.000-05:00","is_admin":false,"about":"software development + open source + web + agile + learning + teaching + pragmatism + clean code + ruby + community + philosophy + music = passion\r\n\r\nYou can find me at http://www.pragtob.info/","is_moderator":false,"karma":211,"avatar_url":"/avatars/PragTob-100.png","invited_by_user":"skade","github_username":"PragTob","twitter_username":"PragTob"},"user_is_author":true,"tags":["elixir","erlang","performance"]},{"short_id":"pv2s4d","short_id_url":"https://lobste.rs/s/pv2s4d","created_at":"2024-01-09T03:37:20.000-06:00","title":"“Elixir is, officially, a gradually typed language”","url":"https://nitter.net/josevalim/status/1744395345872683471","score":80,"flags":0,"comment_count":12,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/pv2s4d/elixir_is_officially_gradually_typed","submitter_user":{"username":"ehamberg","created_at":"2014-08-18T02:47:08.000-05:00","is_admin":false,"about":"https://keybase.io/eh","is_moderator":false,"karma":3889,"avatar_url":"/avatars/ehamberg-100.png","invited_by_user":"oleavr"},"user_is_author":false,"tags":["elixir"]},{"short_id":"uhwjjk","short_id_url":"https://lobste.rs/s/uhwjjk","created_at":"2024-01-09T03:03:17.000-06:00","title":"Introducing the Snowplow Limited Use License Agreement","url":"https://snowplow.io/blog/introducing-snowplow-limited-use-license/","score":1,"flags":1,"comment_count":4,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/uhwjjk/introducing_snowplow_limited_use","submitter_user":{"username":"Tenzer","created_at":"2019-06-24T12:19:29.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":1281,"avatar_url":"/avatars/Tenzer-100.png","invited_by_user":"jamesog"},"user_is_author":false,"tags":["law"]},{"short_id":"0gchjx","short_id_url":"https://lobste.rs/s/0gchjx","created_at":"2024-01-09T02:31:57.000-06:00","title":"Python 3.13 gets a JIT","url":"https://tonybaloney.github.io/posts/python-gets-a-jit.html","score":24,"flags":0,"comment_count":8,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/0gchjx/python_3_13_gets_jit","submitter_user":{"username":"rednafi","created_at":"2023-08-07T16:57:40.000-05:00","is_admin":false,"about":"https://rednafi.com/about","is_moderator":false,"karma":225,"avatar_url":"/avatars/rednafi-100.png","invited_by_user":"polyrand","github_username":"rednafi"},"user_is_author":false,"tags":["python"]},{"short_id":"4fecbg","short_id_url":"https://lobste.rs/s/4fecbg","created_at":"2024-01-09T02:09:54.000-06:00","title":"Database-like ops benchmark","url":"https://duckdblabs.github.io/db-benchmark/","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/4fecbg/database_like_ops_benchmark","submitter_user":{"username":"knl","created_at":"2017-07-21T07:12:24.000-05:00","is_admin":false,"about":"Senior software engineer specialized in distributed systems and low latency, high frequency trading infrastructure.","is_moderator":false,"karma":8607,"avatar_url":"/avatars/knl-100.png","invited_by_user":"james","github_username":"knl","keybase_signatures":[{"kb_username":"knl","sig_hash":"cb1fe17fead6d360f9abca902132b2407ee736f1a243f615ad9757dfe8d17e3b0f"}]},"user_is_author":false,"tags":["databases","performance"]},{"short_id":"c6idjn","short_id_url":"https://lobste.rs/s/c6idjn","created_at":"2024-01-09T01:16:05.000-06:00","title":"Recovering markdown files from generated html","url":"https://drewsh.com/getting-source-back-from-blogposts.html","score":14,"flags":0,"comment_count":14,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/c6idjn/recovering_markdown_files_from","submitter_user":{"username":"crmsnbleyd","created_at":"2023-08-30T03:52:35.000-05:00","is_admin":false,"about":"Church of Emacs \\o/  \r\n[Verifying keyoxide key: $argon2id$v=19$m=64,t=512,p=2$Qg6f4hDlIWPfi0DwtJXXZQ$CB0g5H+Y7JIyXHtdDiMlVw]","is_moderator":false,"karma":183,"avatar_url":"/avatars/crmsnbleyd-100.png","invited_by_user":"WilhelmVonWeiner"},"user_is_author":true,"tags":["unix","web"]},{"short_id":"vdzkjv","short_id_url":"https://lobste.rs/s/vdzkjv","created_at":"2024-01-08T23:48:02.000-06:00","title":"Open Source Durable Execution","url":"https://temporal.io/","score":-1,"flags":2,"comment_count":2,"description":"\u003cp\u003eThis is implementation of Durable Execution, which I think is an interesting concept.\u003c/p\u003e\n","description_plain":"This is implementation of Durable Execution, which I think is an interesting concept.","comments_url":"https://lobste.rs/s/vdzkjv/open_source_durable_execution","submitter_user":{"username":"ilyash","created_at":"2019-05-28T02:09:21.000-05:00","is_admin":false,"about":"Ops and dev","is_moderator":false,"karma":136,"avatar_url":"/avatars/ilyash-100.png","invited_by_user":"orib"},"user_is_author":false,"tags":["programming"]},{"short_id":"2umbin","short_id_url":"https://lobste.rs/s/2umbin","created_at":"2024-01-08T21:58:46.000-06:00","title":"Introducing the OCaml Local Mode","url":"https://www.youtube.com/watch?v=PgUsmO0YyQc\u0026list=PLCiAikFFaMJrgFrWRKn0-1EI3gVZLQJtJ","score":17,"flags":0,"comment_count":3,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/2umbin/introducing_ocaml_local_mode","submitter_user":{"username":"janus","created_at":"2017-09-04T12:41:26.000-05:00","is_admin":false,"about":"My name is Janus Troelsen, I like to work on open source stuff, especially in Haskell and development tools.","is_moderator":false,"karma":745,"avatar_url":"/avatars/janus-100.png","invited_by_user":"singpolyma","github_username":"ysangkok","twitter_username":"ysangkok"},"user_is_author":false,"tags":["ml","performance","video"]},{"short_id":"txcnjn","short_id_url":"https://lobste.rs/s/txcnjn","created_at":"2024-01-08T20:06:00.000-06:00","title":"Memory Safe C++","url":"","score":16,"flags":0,"comment_count":25,"description":"\u003cp\u003eBy now you should have heard that various government agencies are\nissuing clear recommendations against using languages that aren’t\nmemory safe by default. This led many to wonder what the future viability\nof C++ was. I’m an avid C++ programmer but when faced with the reality\nof how software is built, I have to applaud the effort here. Sure,\nmaybe I trust myself to write correct programs but truthfully I simply\nwould feel at least an order of magnitude safer if I knew the\nengineers building critical infrastructure like CT scan machines,\ncommercial airline flight systems, or missile guidance systems were\nforced to use a memory safe language. I think that most reasonable\npeople would admit the same, regretfully or not.\u003c/p\u003e\n\u003cp\u003eAnyway I got to wondering if it was possible to write C++ that was\nsafe by default. I know that people on the Chromium team \u003ca href=\"https://docs.google.com/document/u/0/d/e/2PACX-1vSt2VB1zQAJ6JDMaIA9PlmEgBxz2K5Tx6w2JqJNeYCy0gU4aoubdTxlENSKNSrQ2TXqPWcuwtXe6PlO/pub?pli=1\" rel=\"ugc\"\u003einvestigated\nmodeling the Rust borrow checker using the C++ type\nsystem\u003c/a\u003e\nunsuccessfully. There have also been reports written by C++ committee\nmembers about a “safe subset” of the language which feels like complex\nvaporware. It generally seems like the consensus among everyone is\nthat there is no viable or practical path forward to memory safety in\nC++.\u003c/p\u003e\n\u003cp\u003eSo I thought about it a bit more and came up with a simple (though\nperhaps inefficient) approach to having memory safety in C++ in a way\nthat you can deploy in your projects today, with varying degrees of\ndifficulty. The idea is to provide two additional smart pointer types\nthat mimic \u003ccode\u003eunique_ptr\u003c/code\u003e and \u003ccode\u003eshared_ptr\u003c/code\u003e but explicitly check bounds\non pointer dereference. Additionally they annotate the pointer\ndereference operators with \u003ccode\u003e[[clang::lifetimebound]]\u003c/code\u003e. The combination\nof these two features make it impossible to trigger a use-after-free\nor buffer overflow error at runtime. Here’s the code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C++\"\u003e#ifndef SAFE_PTR_H\n#define SAFE_PTR_H\n\n#include \u0026lt;cstddef\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n\n#include \u0026lt;memory\u0026gt;\n#include \u0026lt;new\u0026gt;\n#include \u0026lt;type_traits\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n#ifdef __clang__\n#define SAFE_PTR_LIFETIME_BOUND [[clang::lifetimebound]]\n#else\n#warning \"No lifetimebound annotation available, code may contain memory vulnerabilities\"\n#define SAFE_PTR_LIFETIME_BOUND\n#endif\n\nnamespace safe_ptr {\n\ntemplate \u0026lt;class PointerType\u0026gt;\nclass safe_ptr_template {\n  PointerType _ptr;\n  std::size_t _size;\n\n  using element_type = typename PointerType::element_type;\n\n  safe_ptr_template(PointerType ptr, std::size_t size) noexcept\n    : _ptr(std::move(ptr)), _size(std::move(size)) {\n  }\n\npublic:\n  template \u0026lt;class... Args\u0026gt;\n  static safe_ptr_template\u0026lt;PointerType\u0026gt; make_nothrow(Args \u0026amp;\u0026amp; ...args)\n    noexcept(noexcept(new (std::nothrow) element_type(std::forward\u0026lt;Args\u0026gt;(args)...))) {\n    std::size_t n = 1;\n    auto *ptr = new (std::nothrow) element_type(std::forward\u0026lt;Args\u0026gt;(args)...);\n    if (!ptr) {\n      n = 0;\n    }\n    return safe_ptr_template\u0026lt;PointerType\u0026gt;(PointerType(ptr), n);\n  }\n\n  static safe_ptr_template\u0026lt;PointerType\u0026gt; make_array_nothrow(std::size_t n)\n    noexcept(noexcept(new (std::nothrow) element_type[n])) {\n    element_type *ptr = new (std::nothrow) element_type[n];\n    if (!ptr) {\n      n = 0;\n    }\n    return safe_ptr_template\u0026lt;PointerType\u0026gt;(PointerType(ptr), n);\n  }\n\n  safe_ptr_template(safe_ptr_template\u0026lt;PointerType\u0026gt; \u0026amp;\u0026amp; args) noexcept\n    : safe_ptr_template(std::move(args._ptr), args._size) {\n    args._size = 0;\n  }\n\n  safe_ptr_template\u0026lt;PointerType\u0026gt; \u0026amp;operator=(safe_ptr_template\u0026lt;PointerType\u0026gt; \u0026amp;\u0026amp; args) noexcept {\n    this-\u0026gt;~safe_ptr_template();\n    new (this) safe_ptr_template\u0026lt;PointerType\u0026gt;(std::move(args));\n    return *this;\n  }\n\n  operator bool() noexcept {\n    return !!_size;\n  }\n\n  element_type \u0026amp;operator[](std::size_t idx) noexcept SAFE_PTR_LIFETIME_BOUND {\n    if (_size \u0026lt;= idx) {\n      std::abort();\n    }\n    return _ptr.get()[idx];\n  }\n\n  element_type \u0026amp;operator *() noexcept SAFE_PTR_LIFETIME_BOUND {\n    if (!_size) {\n      std::abort();\n    }\n\n    return *_ptr.get();\n  }\n\n  element_type *operator-\u0026gt;() noexcept {\n    if (!_size) {\n      std::abort();\n    }\n    return _ptr.get();\n  }\n};\n\ntemplate\u0026lt;class T\u0026gt;\nusing safe_ptr = safe_ptr_template\u0026lt;std::unique_ptr\u0026lt;T\u0026gt;\u0026gt;;\n\ntemplate \u0026lt;class T, class... Args\u0026gt;\nsafe_ptr\u0026lt;T\u0026gt; make_safe_ptr_nothrow(Args \u0026amp;\u0026amp; ...args)\n  noexcept(noexcept(safe_ptr\u0026lt;T\u0026gt;::make_nothrow(std::forward\u0026lt;Args\u0026gt;(args)...))) {\n  return safe_ptr\u0026lt;T\u0026gt;::make_nothrow(std::forward\u0026lt;Args\u0026gt;(args)...);\n}\n\ntemplate \u0026lt;class T\u0026gt;\nsafe_ptr\u0026lt;T[]\u0026gt; make_safe_ptr_array_nothrow(std::size_t n)\n  noexcept(noexcept(safe_ptr\u0026lt;T[]\u0026gt;::make_array_nothrow(n))) {\n  return safe_ptr\u0026lt;T[]\u0026gt;::make_array_nothrow(n);\n}\n}\n\n#endif // SAFE_PTR_H\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is an example usage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C++\"\u003e#include \"safe_ptr.h\"\n\n#include \u0026lt;stdlib.h\u0026gt;\n\nint main(int argc, char *argv[]) {\n  if (argc \u0026lt; 2) return -1;\n\n  int n = atoi(argv[1]);\n\n  auto h = safe_ptr::make_safe_ptr_nothrow\u0026lt;int\u0026gt;();\n  h[n] = 10;\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow let’s run  that with “-O3”\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-console\"\u003e$ clang++ -O3 -Wall test.cc\n$ ./a.out 10\nAborted (core dumped)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you run the debugger on the dumped core you’ll find the stack trace\nat which the \u003ccode\u003eabort()\u003c/code\u003e call occured. What about use-after-free?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-C++\"\u003eint main(int argc, char *argv[]) {\n  int \u0026amp; n = *safe_ptr::make_safe_ptr_nothrow\u0026lt;int\u0026gt;();\n  return n;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-console\"\u003e$ clang++ -O3 -Wall test.cc\ntest.cc:6:14: warning: temporary bound to local reference 'n' will be destroyed at the end of the full-expression\n      [-Wdangling]\n  int \u0026amp; n = *safe_ptr::make_safe_ptr_nothrow\u0026lt;int\u0026gt;();\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 warning generated.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVery nice.\u003c/p\u003e\n\u003cstrong\u003eBig Ifs\u003c/strong\u003e\n\u003cp\u003eThe nice thing about this tool is that it requires no tool support\noutside of \u003ccode\u003e[[clang:lifetimebound]]\u003c/code\u003e so it can be deployed anywhere\neasily. This also makes it easy to modify to your needs. The bad part\nabout this is that it requires your entire codebase to use these smart\npointer classes. For large C++ applications this is not practical but\nfor smaller projects it’s doable.\u003c/p\u003e\n\u003cp\u003eA related concern is that you need to either ban the use of raw\npointers or require that they are only used within a compiler\nannotated “unsafe” block similar to Rust. It would be nice if the\nmainstream C++ compilers added a warning on the use of raw pointers.\u003c/p\u003e\n\u003cp\u003eAnother approach, if you are able to do it, is to modify your C++\nstandard library and add the runtime checks and function annotations\nto \u003ccode\u003eunique_ptr\u003c/code\u003e itself. This doesn’t work for arrays, so you’ll still\nhave to make explicit references to the safe array version.\u003c/p\u003e\n\u003cp\u003eWe should also be concerned about stack array types like \u003ccode\u003eint arr[]\u003c/code\u003e and\n\u003ccode\u003estd::array\u0026lt;int\u0026gt; arr\u003c/code\u003e. You’ll need safe versions of those as well.\u003c/p\u003e\n\u003cp\u003eOne last point, you’ll notice that this smart pointer is larger than a\nstandard pointer by the size of \u003ccode\u003estd::size_t\u003c/code\u003e. One optimization is to make the \u003ccode\u003esafe_ptr\u0026lt;T\u0026gt;\u003c/code\u003e type distinct from the \u003ccode\u003esafe_ptr\u0026lt;T[]\u0026gt;\u003c/code\u003e type,\nthis allows the former type to not require an extra \u003ccode\u003e_size\u003c/code\u003e\nmember. Another optimization is that you can use the high bits of the\npointer on popular contemporary 64-bit platforms to store the number\nof elements (since those bits are unused). If the number of elements is\nlarger than that space, just return an allocation error. This works\nbecause it’s likely you’ll only need to allocate very large arrays in\na few special places.\u003c/p\u003e\n\u003cp\u003eThere are probably many other caveats that apply but the point of this\npost was to raise awareness about this simple approach and to provide a\npractical path forward to memory safety in C++.\u003c/p\u003e\n","description_plain":"By now you should have heard that various government agencies are\r\nissuing clear recommendations against using languages that aren't\r\nmemory safe by default. This led many to wonder what the future viability\r\nof C++ was. I'm an avid C++ programmer but when faced with the reality\r\nof how software is built, I have to applaud the effort here. Sure,\r\nmaybe I trust myself to write correct programs but truthfully I simply\r\nwould feel at least an order of magnitude safer if I knew the\r\nengineers building critical infrastructure like CT scan machines,\r\ncommercial airline flight systems, or missile guidance systems were\r\nforced to use a memory safe language. I think that most reasonable\r\npeople would admit the same, regretfully or not.\r\n\r\nAnyway I got to wondering if it was possible to write C++ that was\r\nsafe by default. I know that people on the Chromium team [investigated\r\nmodeling the Rust borrow checker using the C++ type\r\nsystem](https://docs.google.com/document/u/0/d/e/2PACX-1vSt2VB1zQAJ6JDMaIA9PlmEgBxz2K5Tx6w2JqJNeYCy0gU4aoubdTxlENSKNSrQ2TXqPWcuwtXe6PlO/pub?pli=1)\r\nunsuccessfully. There have also been reports written by C++ committee\r\nmembers about a \"safe subset\" of the language which feels like complex\r\nvaporware. It generally seems like the consensus among everyone is\r\nthat there is no viable or practical path forward to memory safety in\r\nC++.\r\n\r\nSo I thought about it a bit more and came up with a simple (though\r\nperhaps inefficient) approach to having memory safety in C++ in a way\r\nthat you can deploy in your projects today, with varying degrees of\r\ndifficulty. The idea is to provide two additional smart pointer types\r\nthat mimic `unique_ptr` and `shared_ptr` but explicitly check bounds\r\non pointer dereference. Additionally they annotate the pointer\r\ndereference operators with `[[clang::lifetimebound]]`. The combination\r\nof these two features make it impossible to trigger a use-after-free\r\nor buffer overflow error at runtime. Here's the code:\r\n\r\n```C++\r\n#ifndef SAFE_PTR_H\r\n#define SAFE_PTR_H\r\n\r\n#include \u003ccstddef\u003e\r\n#include \u003ccstdlib\u003e\r\n\r\n#include \u003cmemory\u003e\r\n#include \u003cnew\u003e\r\n#include \u003ctype_traits\u003e\r\n#include \u003cutility\u003e\r\n\r\n#ifdef __clang__\r\n#define SAFE_PTR_LIFETIME_BOUND [[clang::lifetimebound]]\r\n#else\r\n#warning \"No lifetimebound annotation available, code may contain memory vulnerabilities\"\r\n#define SAFE_PTR_LIFETIME_BOUND\r\n#endif\r\n\r\nnamespace safe_ptr {\r\n\r\ntemplate \u003cclass PointerType\u003e\r\nclass safe_ptr_template {\r\n  PointerType _ptr;\r\n  std::size_t _size;\r\n\r\n  using element_type = typename PointerType::element_type;\r\n\r\n  safe_ptr_template(PointerType ptr, std::size_t size) noexcept\r\n    : _ptr(std::move(ptr)), _size(std::move(size)) {\r\n  }\r\n\r\npublic:\r\n  template \u003cclass... Args\u003e\r\n  static safe_ptr_template\u003cPointerType\u003e make_nothrow(Args \u0026\u0026 ...args)\r\n    noexcept(noexcept(new (std::nothrow) element_type(std::forward\u003cArgs\u003e(args)...))) {\r\n    std::size_t n = 1;\r\n    auto *ptr = new (std::nothrow) element_type(std::forward\u003cArgs\u003e(args)...);\r\n    if (!ptr) {\r\n      n = 0;\r\n    }\r\n    return safe_ptr_template\u003cPointerType\u003e(PointerType(ptr), n);\r\n  }\r\n\r\n  static safe_ptr_template\u003cPointerType\u003e make_array_nothrow(std::size_t n)\r\n    noexcept(noexcept(new (std::nothrow) element_type[n])) {\r\n    element_type *ptr = new (std::nothrow) element_type[n];\r\n    if (!ptr) {\r\n      n = 0;\r\n    }\r\n    return safe_ptr_template\u003cPointerType\u003e(PointerType(ptr), n);\r\n  }\r\n\r\n  safe_ptr_template(safe_ptr_template\u003cPointerType\u003e \u0026\u0026 args) noexcept\r\n    : safe_ptr_template(std::move(args._ptr), args._size) {\r\n    args._size = 0;\r\n  }\r\n\r\n  safe_ptr_template\u003cPointerType\u003e \u0026operator=(safe_ptr_template\u003cPointerType\u003e \u0026\u0026 args) noexcept {\r\n    this-\u003e~safe_ptr_template();\r\n    new (this) safe_ptr_template\u003cPointerType\u003e(std::move(args));\r\n    return *this;\r\n  }\r\n\r\n  operator bool() noexcept {\r\n    return !!_size;\r\n  }\r\n\r\n  element_type \u0026operator[](std::size_t idx) noexcept SAFE_PTR_LIFETIME_BOUND {\r\n    if (_size \u003c= idx) {\r\n      std::abort();\r\n    }\r\n    return _ptr.get()[idx];\r\n  }\r\n\r\n  element_type \u0026operator *() noexcept SAFE_PTR_LIFETIME_BOUND {\r\n    if (!_size) {\r\n      std::abort();\r\n    }\r\n\r\n    return *_ptr.get();\r\n  }\r\n\r\n  element_type *operator-\u003e() noexcept {\r\n    if (!_size) {\r\n      std::abort();\r\n    }\r\n    return _ptr.get();\r\n  }\r\n};\r\n\r\ntemplate\u003cclass T\u003e\r\nusing safe_ptr = safe_ptr_template\u003cstd::unique_ptr\u003cT\u003e\u003e;\r\n\r\ntemplate \u003cclass T, class... Args\u003e\r\nsafe_ptr\u003cT\u003e make_safe_ptr_nothrow(Args \u0026\u0026 ...args)\r\n  noexcept(noexcept(safe_ptr\u003cT\u003e::make_nothrow(std::forward\u003cArgs\u003e(args)...))) {\r\n  return safe_ptr\u003cT\u003e::make_nothrow(std::forward\u003cArgs\u003e(args)...);\r\n}\r\n\r\ntemplate \u003cclass T\u003e\r\nsafe_ptr\u003cT[]\u003e make_safe_ptr_array_nothrow(std::size_t n)\r\n  noexcept(noexcept(safe_ptr\u003cT[]\u003e::make_array_nothrow(n))) {\r\n  return safe_ptr\u003cT[]\u003e::make_array_nothrow(n);\r\n}\r\n}\r\n\r\n#endif // SAFE_PTR_H\r\n```\r\n\r\nHere is an example usage:\r\n\r\n```C++\r\n#include \"safe_ptr.h\"\r\n\r\n#include \u003cstdlib.h\u003e\r\n\r\nint main(int argc, char *argv[]) {\r\n  if (argc \u003c 2) return -1;\r\n\r\n  int n = atoi(argv[1]);\r\n\r\n  auto h = safe_ptr::make_safe_ptr_nothrow\u003cint\u003e();\r\n  h[n] = 10;\r\n  return 0;\r\n}\r\n```\r\n\r\nNow let's run  that with \"-O3\"\r\n\r\n```console\r\n$ clang++ -O3 -Wall test.cc\r\n$ ./a.out 10\r\nAborted (core dumped)\r\n```\r\n\r\nIf you run the debugger on the dumped core you'll find the stack trace\r\nat which the `abort()` call occured. What about use-after-free?\r\n\r\n```C++\r\nint main(int argc, char *argv[]) {\r\n  int \u0026 n = *safe_ptr::make_safe_ptr_nothrow\u003cint\u003e();\r\n  return n;\r\n}\r\n```\r\n\r\n```console\r\n$ clang++ -O3 -Wall test.cc\r\ntest.cc:6:14: warning: temporary bound to local reference 'n' will be destroyed at the end of the full-expression\r\n      [-Wdangling]\r\n  int \u0026 n = *safe_ptr::make_safe_ptr_nothrow\u003cint\u003e();\r\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n1 warning generated.\r\n```\r\n\r\nVery nice.\r\n\r\n## Big Ifs\r\n\r\nThe nice thing about this tool is that it requires no tool support\r\noutside of `[[clang:lifetimebound]]` so it can be deployed anywhere\r\neasily. This also makes it easy to modify to your needs. The bad part\r\nabout this is that it requires your entire codebase to use these smart\r\npointer classes. For large C++ applications this is not practical but\r\nfor smaller projects it's doable.\r\n\r\nA related concern is that you need to either ban the use of raw\r\npointers or require that they are only used within a compiler\r\nannotated \"unsafe\" block similar to Rust. It would be nice if the\r\nmainstream C++ compilers added a warning on the use of raw pointers.\r\n\r\nAnother approach, if you are able to do it, is to modify your C++\r\nstandard library and add the runtime checks and function annotations\r\nto `unique_ptr` itself. This doesn't work for arrays, so you'll still\r\nhave to make explicit references to the safe array version.\r\n\r\nWe should also be concerned about stack array types like `int arr[]` and\r\n`std::array\u003cint\u003e arr`. You'll need safe versions of those as well.\r\n\r\nOne last point, you'll notice that this smart pointer is larger than a\r\nstandard pointer by the size of `std::size_t`. One optimization is to make the `safe_ptr\u003cT\u003e` type distinct from the `safe_ptr\u003cT[]\u003e` type,\r\nthis allows the former type to not require an extra `_size`\r\nmember. Another optimization is that you can use the high bits of the\r\npointer on popular contemporary 64-bit platforms to store the number\r\nof elements (since those bits are unused). If the number of elements is\r\nlarger than that space, just return an allocation error. This works\r\nbecause it's likely you'll only need to allocate very large arrays in\r\na few special places.\r\n\r\nThere are probably many other caveats that apply but the point of this\r\npost was to raise awareness about this simple approach and to provide a\r\npractical path forward to memory safety in C++.","comments_url":"https://lobste.rs/s/txcnjn/memory_safe_c","submitter_user":{"username":"PhantomZorba","created_at":"2022-04-18T15:29:33.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":333,"avatar_url":"/avatars/PhantomZorba-100.png","invited_by_user":"sirwart"},"user_is_author":true,"tags":["c++","show"]}]